import math
import numpy as np
import matplotlib.pyplot as plt
import random
import os
from tdc import TDC
import argparse
    
def saveToFile(INL, DNL, countsPerCode, filledCode):
    with open("INLSimulated.csv", "w") as csvFile:
        for value in INL[1:filledCode]:
            csvFile.write(f"{value}\n")
    with open("DNLSimulated.csv", "w") as csvFile:
        for value in DNL[1:filledCode]:
            csvFile.write(f"{value}\n")
    with open("BinLengthSimulated.csv", "w") as csvFile:
        for value in counts[0:filledCode+1]:
            csvFile.write(f"{value/1000}\n")
   
#This simulation assumed that the rising edge of the signal in arrives at 0 femtosecond to the chain
#Then a code density is generated by moving the clock arrival in the chain, timeCounter representing the delay between the arrival of the start signal and clock arrival
#each femtosecond from 0 to the clock period is simulated
def simulate(data_folder):
    analysis = "avg" #"min", "max" or "avg", indicates if the simulated must used to min or max delay values or compute the average of the two to simulate.
    
    if("UltraScale+" in data_folder):
        clkFrequencyMhz = 700
        architecture = "u+"
    elif("virtex7" in data_folder):
        clkFrequencyMhz = 540
        architecture = "s7"
    else:
        clkFrequencyMhz = 625
        architecture = "u"
        
    clkPeriod = math.floor(1000000000/(clkFrequencyMhz)) #in fs
    clkJitter = 1250 #Cycle to cycle jitter in fs
    typeOfTDC = "bilateral" #bilateral or unilateral

    tdc = TDC(clkPeriod, clkJitter)
    tdc.addFineInterpolator(data_folder, architecture, "_0", analysis, 0)
    tdc.addFineInterpolator(data_folder, architecture, "_1", analysis, 0)
    tdc.testFineInterpolator(0,clkPeriod,data_folder) 
    tdc.testFineInterpolator(1,clkPeriod,data_folder) 

    rangeTest = 5*clkPeriod
    rangeRandomDelay = 10*clkPeriod
    deterministicDelay = 0# in fs
    diffTimeList = []
    nList = []
    
    tdc.channelDelay[1] = deterministicDelay
    
    for time in range(1,rangeTest):
        randomDelay = random.uniform(0,rangeRandomDelay)
        codeList = tdc.measure2Channel(randomDelay,randomDelay+time, 0, 1)
        timeList = tdc.retrieveTime(codeList, [0,1])
        estimatedTime = (timeList[1]-deterministicDelay) - timeList[0]
        nList.append(abs(codeList[0][1] - codeList[1][1]))
        diffTimeList.append(estimatedTime-time)
    
    if(typeOfTDC == "bilateral"):
        for time in range(1,rangeTest):
            randomDelay = random.uniform(0,rangeRandomDelay)
            codeList = tdc.measure2Channel(randomDelay+time,randomDelay, 0, 1)
            timeList = tdc.retrieveTime(codeList, [0,1])
            estimatedTime = timeList[0] - (timeList[1]-deterministicDelay)
            nList.append(abs(codeList[0][1] - codeList[1][1]))
            diffTimeList.append(estimatedTime-time)
     
    qErrorCh1 = tdc.fineInterpolators[0].simulatedPrecision
    qErrorCh2 = tdc.fineInterpolators[1].simulatedPrecision
    
    if(typeOfTDC == "bilateral"):
        if(deterministicDelay > rangeTest):
            clkJitterError = ((deterministicDelay/clkPeriod)**0.5)*clkJitter
        else:
            clkJitterError = ((((rangeTest+(deterministicDelay**2/rangeTest)))/(2*clkPeriod))**0.5)*clkJitter 
    else:
        clkJitterError = ((((rangeTest+(deterministicDelay*2)))/(2*clkPeriod))**0.5)*clkJitter 
        
    ePrecision = (qErrorCh1**2 + qErrorCh2**2 + clkJitterError**2)**0.5
    with open(data_folder+"/results.txt", "w") as textFile:
        textFile.write(f"Simulated Precision: {np.std(diffTimeList)/1000}, Ch1 qError: {qErrorCh1/1000}, Ch2 qError: {qErrorCh2/1000}, Clk jitter error: {clkJitterError/1000}, Expected Precision = {ePrecision/1000}")
    
    plt.hist(diffTimeList)
    plt.savefig(data_folder+"/timeHist.png")
    plt.close()
    

if __name__ == '__main__':
    parser = argparse.ArgumentParser(usage='%(prog)s directory')
    parser.add_argument('directory', help='Directory containing the csv delays and skew files')
    args = parser.parse_args()
    simulate(args.directory)